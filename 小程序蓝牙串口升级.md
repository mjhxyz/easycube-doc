# 小程序蓝牙串口升级

分为三个关键步骤:

1. 小程序中获取升级文件
2. 升级文件传输到盒子
3. 盒子自升级

##  小程序中获取升级文件

1. 盒子发送的心跳包中携带 `当前软件的版本号v(n)`, 小程序拿到后，暂存到 `LocalStorage` 中
2. 用户点击 `检查更新` 时, 请求 `后端接口`, 用来检查是否有新的版本。请求接口时，携带版本号和 mac 信息
3. 后端接口将 `最新的版本v(m)` 和 `v(n)` 进行比较
    1. 如果 `v(m)` <= `v(n)`, 则不用进行升级，返回空
    2. 如果存在 `v(m)` > `v(n)` 则返回 `v(n)+1` 版本的新文件数据
4. 新版本文件数据包括:
    1. meta: 所有的新文件的(文件名, 文件大小, 文件md5)
    2. {0->n} 文件数据
5. 获取新版数据后，暂存在 LocaStorage 中
6. 小程序中开启一个升级任务，目的是 `将升级后的文件数据安全的传输到盒子中`

## 升级文件传输到盒子

1. 小程序发送一个 `upgrade` 请求, 携带所有升级文件的元信息`(版本号 文件名 文件大小 文件md5)`
2. 盒子接受到 upgrade 请求后, 假设新的版本是 `v(m)`，当前盒子版本是 `v(n)`
   1. 如果 `v(m)` <= `v(n)` 或者 `v(m)` 文件夹已经存在, 则抛弃这些数据
   2. 如果 `v(m)` > `v(n)`
        1. 则创建文件夹 `upgrade/v(m)`
        2. 将所有更新文件的数据写入 mate 文件中 (文件名 文件大小 文件md5)
3. 小程序发送若干 `patch` 请求, 携带 `(版本号 文件名 数据偏移 文件数据块)`
4. 盒子接收到 `patch` 请求后
   1. 如果 `v(m)` <= `v(n)` 则抛弃请求
   2. 检查 `v(m)` 是否存在，如果不存在，则抛弃请求
   3. 检查文件 `upgrade/v(m)/{0->n}` 的内容字节数是否等于`数据偏移`
        1. 如果相等，则说明 patch 携带的是下一个文件块，此时追加到 `upgrade/v(m)/{0->}` 中
        2. 返回给小程序文件 `upgrade/v(m)/{0->}` 的大小，当作下一次的 `数据偏移`

## 盒子自升级

1. sqlite 数据库配置表中，添加一个当前版本的字段 `v(n)`
2. 运行目录中添加一个 `upgrade` 文件夹，用于临时存储升级的文件夹
   1. 里面放着类似 `v1` `v2` 这样的子文件夹
   2. 子文件夹中，存在两种文件
        1. `meta`: 用于存放升级文件列表的数据  `(文件大小, 文件md5, 文件名)`
        2. `{0->n}`: 文件名为数字的文件,存放 `升级后文件的内容`
3. 添加一个升级检测程序
    1. 定期检查 `v(n)` 和 `upgrade` 中的数据
        1. 如果 upgrade 中存在 `v(m)`<=`v(n)`, 那么删除 v(m) (已经升级完成的版本)
        2. 如果 upgrade 中存在 `v(m)`==`v(n)+1`, 那么此时 v(m) 满足升级要求
    2. 对于所有需要升级的文件，检查文件的完整性
        1. `检查文件大小`: 比较 `(0->n)` 实际大小和 `meta` 中标记的文件大小
            1. 如果 size of {0->n} > meta, 则说明数据存在严重错误，需要直接删除这个新的版本
            2. 如果 size of newfile < meta, 则说明新版本的文件还在传输过程中
            3. 如果 size of newfile = meta, 则说明新版本已经传输完成，下一步验证数据完整
        2. `检查文件md5`
            1. 不相同，则新版本文件传输过程中受损 需要删除
            2. 相同,则新版本文件传输成功
    3. 满足升级条件和文件完整性后开始升级
        1. `遍历 meta 文件`: 用来获取升级的信息(文件大小，文件md5, 文件名)
        2. `复制升级文件`: cp ./upgrade/{0->n} /root/easycube-py/文件名
        3. `设置更新后的版本号`: v(n) + 1
        4. `运行部署程序`: ./deploy
        5. `重新载入守护程序`: supervisor reload

